
# 谈谈C/C++的编译模型


为什么C语言有预处理
---
在今天来说, C语言支持将一个大程序分成多个源文件来编译的功能是很有用的, 但是这事实上是历史原因对于内存不足的妥协, 早起的C编译器运行在内存仅有 16-bit 的机器上, 程序和数据挤在这 64KiB 的空间, 编译器无法在内存中表示单个源文件的抽象语法树, 更不可能将整个程序(多个源文件)放在内存中. 所以编译器必须能分别编译多个源文件, 生成不同的目标文件, 然后将目标文件链接在一起成为可执行文件(ELF).

为了尽量减少内存使用, C语言使用“隐式函数声明”, 代码使用前文未定义的函数时, 编译器不需要也不会检查**函数原型**(参数个数, 参数类型, 返回值类型), 这也就是为什么我们写C语言的时候, 哪怕不引入头文件也可以使用 printf 函数(部分编译器如gcc), 还解释了为什么如果我们不小心打错了函数名, 给出的报错信息是ld(链接器)发出的链接失败(error: ld returned 1 exit status)而不是编译错误(gcc编译器). 默认未声名的函数返回类型为**int**.

其实有了隐式函数声明就已经有了分别编译多个源文件的能力, 然后就可以将它们链接为一个可执行文件(ELF), 预处理和头文件的设计也是因为历史原因造成, 最初的Unix是把内核数据结构打印在手册上, 然后每个程序自己在代码中定义struct, 加入了预处理和头文件的设计后就可以将这些公共信息放在 /usr/include 可以减少无谓的错误, 挺好代码移植性.

C语言的编译模型
---

上文提到因为不能将整个源文件的语法树保存在内存中, 所以C语言时按照“单遍编译”来设计的. 也就是从头到尾扫一遍源码, 一边解析, 一边生成代码. 编译时, 编译器只能看到当前已经解析过的代码, 看不到之后的代码,并且可以随看随忘, 也就意味着:

+ C语言结构体必须先定义才能访问成员, 否则编译器不知道结构体成员类型和偏移量, 无法立刻生成目标代码
+ 局部变量先定义再使用, 若定义在后方, 编译器不知道类型和在栈中的位置, 无法立刻生成目标代码
+ 局部变量只能在语句块开始处定义(C99之后可以任意位置)
+ 外部变量只需知道类型和名称,不需知道地址, 生成的目标代码中外部变量的地址是空白, 后来由链接器补充
+ 函数调用按照隐式函数声明规则, 编译器可以立刻生成调用函数的汇编代码, 函数地址留空交给链接器

对于C语言编译器来说, 只需要知道struct的**成员类型和地址偏移**, 知道外部变量的类型就可以一边解析源代码一边生成目标代码, 这使得早期的头文件和预处理就可以满足编译器的要求, 外部符号(函数,变量)的具体信息交给链接器去填充.

直到目前来说, C语言对于头文件和预处理的设计的作用都是正面的, 但是对于C++来说就产生了很多负面影响.


C++编译模型
---

因为C++需要对C语言保持兼容, 加上C++本身的复杂性, 原本在C语言中很合适的机制就成了祸害.

C++的单遍编译
--
C++继承了C语言的单遍编译, 根据目前看到的代码做出决策, 读到后面的代码不会影响之前的决定, 这给名字查找(name lookup)和函数重载决议造成了很大影响.

先说名字查找.C++中的名字包含**类型名**,**函数名**,**变量名**,**typedef/using别名**,**template名**.

例如一句 

```C++
Foo<T> a; // Foo, T, a 都不是宏
``` 
如果不知道这三个名字分别代表什么, 编译器就无法进行语法分析, 根据之前所说的几个类别,这个语句有以下几种可能性:

+ Foo 是 template < typename X > class Foo, T 是 Type, 那么这句话就是以 T 为模版类型参数实例化了 Foo < T > 类型, 定义变量 a
+ Foo 是 template < typename X > class Foo, T 是 const int, 那么这句话就是以 T 为非模版类参数实例化了 Foo < T > 类型, 定义变量 a
+ Foo , T, a 都是int, 这句话没什么意义

另外还有 operator <() 所以还会有别的意思, 就像一个经典的例子 AA BB(CC); 这个既可能是定义变量, 还可以是函数声明.

因为C++的 [Run-time]() 十分简陋, 也没有源数据, 这导致它只能解析源码来了解名字的含义, 也就意味着要理解一行C++代码的意义, 需要通读这条代码之前所有的代码, 并理解每一个符号的定义. 因此C++的符号表至少要保存目前已经看到的每个名字的含义, 包括 class 成员定义, 已声明的变量, 已知的函数原型, 甚至还有 template, 以及处理作用域嵌套引发的名字的含义变化(作用域内层名字遮住外层名字).

再说重载决议, C++编译器读到一个函数调用语句时, 必须(也只能)从目前看到的所有的同名函数中取出最佳匹配. 哪怕后面可能会出现更合适的匹配, 也不能影响当前的决定(class除外, 编译器会先扫一遍class的定义再处理成员函数), 这也就意味着如果交换两个相同作用域(namespace)下的函数定义, 可能会改变程序的行为.

例如:

```C++
void foo(int) {
	print("foo(int);\n");
}

void bar() {
	foo('a');
}

void foo(char) {
	print("foo(char);\n");
}

int main() {
	bar();
}

```

这也就解释了为什么C++的重构器那么难做, 因为重构器对于代码的理解水平必须达到编译器的水平, 才能在修改代码时不改变原意.

前向声明
--

